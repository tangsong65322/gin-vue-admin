import Text from "com.google.mlkit.vision.text.Text"
import TextRecognition from "com.google.mlkit.vision.text.TextRecognition"
import TextRecognizer from "com.google.mlkit.vision.text.TextRecognizer"
import TextRecognizerOptionsInterface from "com.google.mlkit.vision.text.TextRecognizerOptionsInterface"
import ChineseTextRecognizerOptions from "com.google.mlkit.vision.text.chinese.ChineseTextRecognizerOptions"
import JapaneseTextRecognizerOptions from "com.google.mlkit.vision.text.japanese.JapaneseTextRecognizerOptions"

import Context from 'android.content.Context'
import IOException from 'java.io.IOException'
import InputStream from 'java.io.InputStream'
import Uri from 'android.net.Uri';
import File from 'java.io.File'
import Bitmap from "android.graphics.Bitmap"
import BarcodeScanner from "com.google.mlkit.vision.barcode.BarcodeScanner"
import BarcodeScannerOptions from "com.google.mlkit.vision.barcode.BarcodeScannerOptions"
import BarcodeScanning from "com.google.mlkit.vision.barcode.BarcodeScanning"
import ZoomSuggestionOptions from "com.google.mlkit.vision.barcode.ZoomSuggestionOptions"
import ZoomCallback from "com.google.mlkit.vision.barcode.ZoomSuggestionOptions.ZoomCallback"
import Barcode from "com.google.mlkit.vision.barcode.common.Barcode"
import InputImage from "com.google.mlkit.vision.common.InputImage"
import Task from "com.google.android.gms.tasks.Task"
import List from "java.util.List"
import ByteBuffer from 'java.nio.ByteBuffer'
import ImageFormat from 'android.graphics.ImageFormat'

import Vibrator from "android.os.Vibrator"


import ContentValues from "android.content.ContentValues"
import ContentUris from "android.content.ContentUris"
import JSONObject from "org.json.JSONObject"
import TimeZone from "java.util.TimeZone"
import Cursor from "android.database.Cursor"
import MediaStore from "android.provider.MediaStore"
import SimpleDateFormat from "java.text.SimpleDateFormat"
import Locale from "java.util.Locale"
import MediaScannerConnection from "android.media.MediaScannerConnection"
import Rect from 'android.graphics.Rect';


type callType = (list:any)=> void;

/**
 * 震动
 * @param {number} duriation 震动时间单位ms
 */
export function vibrator(duriation : number) : boolean {
	try {
		const context = UTSAndroid.getAppContext() as Context
		let vb = context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator;
		if (vb!.hasVibrator()) {
			vb!.vibrate(duriation.toLong());
		} else {
			return false
		}
	} catch (e) {
		console.error(e)

	}
	return false
}


/**
* 从相册/相机中选取图片进行识别
* @param callback {(string[],any[])=>{}} 回调参数:第一个是识别的文本数组,第二个是源数据{boundingBox:[x,y,width,height],text:elementText}[]字符串,需要JSON.pare,携带了坐标等详细资料
* @param language {string} 需要识别的语言 zh中文,ja日文
*/
export function chooseImageBuilder(callback:(str:string[],source:string[])=>void,langs:string|null){
	// 置信度
	let zxd = 0.50
	
	uni.chooseImage({
		count: 1,
		success(evt : ChooseImageSuccess) {
			uni.showLoading({ title: '...', mask: true })
			if (evt.tempFilePaths.length > 0) {
				const imgs = evt.tempFilePaths[0] as string;
				try {
					const decodedPath = UTSAndroid.convert2AbsFullPath(imgs)
					const file = new File(decodedPath)
					let image = InputImage.fromFilePath(UTSAndroid.getAppContext() as Context, Uri.fromFile(file));
					
					let recognizer = TextRecognition.getClient(new ChineseTextRecognizerOptions.Builder().build()) as TextRecognizer;
					if(langs=='ja'){
						recognizer = TextRecognition.getClient(new JapaneseTextRecognizerOptions.Builder().build()) as TextRecognizer;
					}
					recognizer.process(image!)
							.addOnSuccessListener((TextList) => {
								let str = [] as string[]
								let sour = [] as string[]
								for (block in TextList.textBlocks) {
									for (line in block.lines) {
										// let lineText = line.text
										// let lineCornerPoints = line.cornerPoints
										// let lineFrame = line.getBoundingBox 
										let texts = ''
										for (element in line.elements) {
											if (element.getConfidence() >= zxd) {
												let elementText = element.text as string;
												
												let elementFrame = element.getBoundingBox()
												let rect = elementFrame as Rect
												sour.push(JSON.stringify({boundingBox:[rect.left,rect.top,rect.width(),rect.height()],text:elementText} as UTSJSONObject))
												texts+=elementText
												
											}
										}
										if(texts!=''){
											str.push(texts)
										}
									}
								}
								uni.hideLoading()
								vibrator(100)
								callback(str as string[],sour as string[])
							})
							.addOnFailureListener((e) => {
						
								callback([] as string[],[] as string[])
							})
					
	
				} catch (e : IOException) {
					callback([] as string[],[] as string[])
				}
			}
		},
		fail() {
			callback([] as string[],[] as string[])
		}
	})
}

/**
* 从相册/相机中选取图片进行识别
* @param url {string} 图片地址.
* @param callback {(string[],any[])=>{}} 回调参数:第一个是识别的文本数组,第二个是源数据{boundingBox:[x,y,width,height],text:elementText}[]字符串,需要JSON.pare,携带了坐标等详细资料
* @param language {string} 需要识别的语言 zh中文,ja日文
*/
export function downloadUrlImageBuilder(url : string,callback:(str:string[],source:string[])=>void,langs:string|null) {
	// 置信度
	let zxd = 0.50
	uni.downloadFile({
		url,
		success(evt) {
			const contentResolver = UTSAndroid.getAppContext()!.contentResolver
			let decodedPath = UTSAndroid.convert2AbsFullPath(evt.tempFilePath)
	
			try {
				const file = new File(decodedPath)
				let image = InputImage.fromFilePath(UTSAndroid.getAppContext() as Context, Uri.fromFile(file));
				let recognizer = TextRecognition.getClient(new ChineseTextRecognizerOptions.Builder().build()) as TextRecognizer;
				if(langs=='ja'){
					recognizer = TextRecognition.getClient(new JapaneseTextRecognizerOptions.Builder().build()) as TextRecognizer;
				}
				if (image != null) {
					const result = recognizer.process(image!)
						.addOnSuccessListener((TextList) => {
							let str = [] as string[]
							let sour = [] as string[]
							for (block in TextList.textBlocks) {
								for (line in block.lines) {
									let texts = ''
									for (element in line.elements) {
										if (element.getConfidence() >= zxd) {
											let elementText = element.text as string;
											
											let elementFrame = element.getBoundingBox()
											let rect = elementFrame as Rect
											sour.push(JSON.stringify({boundingBox:[rect.left,rect.top,rect.width(),rect.height()],text:elementText} as UTSJSONObject))
											texts+=elementText
											
										}
									}
									if(texts!=''){
										str.push(texts)
									}
								}
							}
							uni.hideLoading()
							vibrator(100)
							callback(str as string[],sour)
						})
						.addOnFailureListener((e) => {
							callback([] as string[],[] as string[])
						})
				} else {
					callback([] as string[],[] as string[])
				}
			} catch (e : IOException) {
				callback([] as string[],[] as string[])
			}
	
		},
		fail() {
			callback([] as string[],[] as string[])
		}
	})
}


/**
* 从相册/相机中选取图片进行识别
* @param pathfile {string} 图片地址.
* @param callback {(string[],any[])=>{}} 回调参数:第一个是识别的文本数组,第二个是源数据{boundingBox:[x,y,width,height],text:elementText}[]字符串,需要JSON.pare,携带了坐标等详细资料
* @param language {string} 需要识别的语言 zh中文,ja日文
*/
export function localFilePathImageBuilder(pathfile : string,callback:(str:string[],source:string[])=>void,langs:string|null){
	// 置信度
	let zxd = 0.50
	try {
		let decodedPath = UTSAndroid.convert2AbsFullPath(pathfile)
		
		const file = new File(decodedPath)
		let image = InputImage.fromFilePath(UTSAndroid.getAppContext() as Context, Uri.fromFile(file));
		let recognizer = TextRecognition.getClient(new ChineseTextRecognizerOptions.Builder().build()) as TextRecognizer;
		if(langs=='ja'){
			recognizer = TextRecognition.getClient(new JapaneseTextRecognizerOptions.Builder().build()) as TextRecognizer;
		}
		
		if (image != null) {
			const result = recognizer.process(image!)
				.addOnSuccessListener((TextList) => {
					let str = [] as string[]
					let sour = [] as string[]
					for (block in TextList.textBlocks) {
						for (line in block.lines) {
							let texts = ''
							for (element in line.elements) {
								if (element.getConfidence() >= zxd) {
									let elementText = element.text as string;
									
									let elementFrame = element.getBoundingBox()
									let rect = elementFrame as Rect
									sour.push(JSON.stringify({boundingBox:[rect.left,rect.top,rect.width(),rect.height()],text:elementText} as UTSJSONObject))
									texts+=elementText
									
								}
							}
							if(texts!=''){
								str.push(texts)
							}
						}
					}
					callback(str as string[],sour)
				})
				.addOnFailureListener((e) => {
					callback([] as string[],[] as string[])
				})
		} else {
			callback([] as string[],[] as string[])
		}
	} catch (e : IOException) {
		callback([] as string[],[] as string[])
	}
}

